        -:    0:Source:Password.cpp
        -:    0:Graph:Password.gcno
        -:    0:Data:Password.gcda
        -:    0:Runs:1
        -:    1:#include "Password.h"
        -:    2:#include <string>
        -:    3:#include <cctype>
        -:    4:
        -:    5:using std::string;
        -:    6:
        -:    7:/*
        -:    8:  The function receives a string counts how many times the same character
        -:    9:  occurs at the beginning of the string, before any other characters (or the
        -:   10:  end of the string). The function is case-sensitive so 'Z' is different than
        -:   11:  'z' and any ASCII characters are allowed.
        -:   12:*/
function _ZN8Password24count_leading_charactersENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 4 returned 100% blocks executed 100%
        4:   13:int Password::count_leading_characters(string phrase)
        -:   14:{
        4:   15:  if (phrase.length() == 0)
call    0 returned 4
branch  1 taken 1 (fallthrough)
branch  2 taken 3
        -:   16:  {
        1:   17:    return 0;
        -:   18:  }
        3:   19:  int repetition = 1;
        3:   20:  int index = 0;
        5:   21:  while (index < phrase.length() - 1 && phrase[index] == phrase[index + 1])
call    0 returned 5
branch  1 taken 3 (fallthrough)
branch  2 taken 2
call    3 returned 3
call    4 returned 3
branch  5 taken 2 (fallthrough)
branch  6 taken 1
branch  7 taken 2
branch  8 taken 3 (fallthrough)
        -:   22:  {
        2:   23:    repetition++;
        2:   24:    index++;
        -:   25:  }
        3:   26:  return repetition;
        -:   27:}
        -:   28:
        -:   29:/*
        -:   30:  receives a string and returns whether it has both at least one upper-case
        -:   31:  letter and at least one lower-case letter
        -:   32:*/
function _ZN8Password14has_mixed_caseENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 4 returned 100% blocks executed 100%
        4:   33:bool Password::has_mixed_case(string str)
        -:   34:{
        4:   35:  bool has_lower = false;
        4:   36:  bool has_upper = false;
       25:   37:  for (char ch : str)
call    0 returned 4
call    1 returned 4
call    2 returned 21
call    3 returned 21
call    4 returned 25
branch  5 taken 21
branch  6 taken 4 (fallthrough)
        -:   38:  {
       21:   39:    if (std::islower(ch))
branch  0 taken 9 (fallthrough)
branch  1 taken 12
        -:   40:    {
        9:   41:      has_lower = true;
        -:   42:    }
       12:   43:    else if (std::isupper(ch))
branch  0 taken 6 (fallthrough)
branch  1 taken 6
        -:   44:    {
        6:   45:      has_upper = true;
        -:   46:    }
        -:   47:  }
        4:   48:  return has_lower && has_upper;
branch  0 taken 2 (fallthrough)
branch  1 taken 2
branch  2 taken 1 (fallthrough)
branch  3 taken 1
        -:   49:}
        -:   50:
        -:   51:/*
        -:   52:  Receives a string and returns a count of how many case-sensitive unique characters there are. 
        -:   53:  If there are duplicate instances of the same character it should only count as a single character. 
        -:   54:  Even if characters look similar, as long as they have distinct ASCII values, they should qualify as unique characters.
        -:   55:*/
function _ZN8Password17unique_charactersENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 2 returned 100% blocks executed 100%
        2:   56:unsigned int Password::unique_characters(string str)
        -:   57:{
        -:   58:  // Use a boolean array to track which ASCII characters have been seen
        -:   59:  // ASCII range is 0-255
        2:   60:  bool seen[256] = {false};
        2:   61:  unsigned int count = 0;
        -:   62:  
       10:   63:  for (char ch : str)
call    0 returned 2
call    1 returned 2
call    2 returned 8
call    3 returned 8
call    4 returned 10
branch  5 taken 8
branch  6 taken 2 (fallthrough)
        -:   64:  {
        -:   65:    // Convert char to unsigned char to ensure index is in range 0-255
        8:   66:    unsigned char index = static_cast<unsigned char>(ch);
        8:   67:    if (!seen[index])
branch  0 taken 5 (fallthrough)
branch  1 taken 3
        -:   68:    {
        5:   69:      seen[index] = true;
        5:   70:      count++;
        -:   71:    }
        -:   72:  }
        -:   73:  
        2:   74:  return count;
        -:   75:}
